function BHO_Lines_4(CWT_Input_Features_Matrix,All_Data_Matrix, Values, Number_of_Features_used_for_Lineaments_Detection, N_Scales, Line_Res, DR, SDF, sigma2)
%--------------------------------------------------------------------------
% FUNCTION: BHO_Lines_4
%
% PURPOSE:
%   Executes a complete, automated lineament detection workflow using a
%   set of hyperparameters determined from Bayesian Hyperparameter
%   Optimization (BHO). The function takes raw data and an optimized
%   parameter vector (`Values`) to perform CWT, feature selection, lineament
%   extraction, and classification.
%
%   The workflow is as follows:
%   1.  **CWT**: Generates wavelet coefficients using optimized parameters.
%   2.  **Feature Selection**: Reduces CWT features based on saliency and dissimilarity.
%   3.  **Lineament Extraction**: Detects lineaments from selected features.
%   4.  **Classification & Stacking**: Classifies lineaments as "deep" or "shallow"
%       based on the adaptive step-filter width and creates composite maps.
%   5.  **Shapefile Generation**: Converts the raster lineament maps into
%       vector shapefiles for use in GIS software.
%   6.  **Density Map**: Calculates a final lineament density map.
%
%   This function does not return values directly but saves all its outputs
%   (images, shapefiles, etc.) to global variables for use in a larger application.
%
% AUTHOR:
%   Bahman Abbassi
%   University of Quebec (UQAT)
%   Email: bahman.abbassi@uqat.ca
%   GitHub: https://github.com/bahmanabbassi
%   MathWorks: https://www.mathworks.com/matlabcentral/profile/authors/31336389
%
% INPUTS:
%   CWT_Input_Features_Matrix (double): 2D/3D matrix for CWT analysis.
%   All_Data_Matrix (double):           3D matrix of additional data to combine
%                                       with CWT features.
%   Values (double array):              A vector containing the optimized
%                                       hyperparameters from BHO.
%   Number_of_Features_used_for_Lineaments_Detection (integer): Not directly used,
%                                       recalculated internally.
%   N_Scales (integer):                 Number of CWT scales.
%   Line_Res (double):                  Resize factor for feature maps.
%   DR (integer):                       Target number of features after reduction.
%   SDF (double):                       Scale step for CWT.
%   sigma2 (double):                    Sigma for the Gaussian filter (`FilterB`).
%
% GLOBAL OUTPUTS (Generated by this function):
%   plotH1_rgb (double):        Image of all detected lineaments.
%   plotH1_rgb_Deep (double):   Image of "deep" lineaments only.
%   plotH1_rgb_Shallow (double):Image of "shallow" lineaments only.
%   Shape_Auto (struct):        Shapefile structure for all lineaments.
%   Shape_Deep_Auto (struct):   Shapefile structure for deep lineaments.
%   Shape_Shallow_Auto (struct):Shapefile structure for shallow lineaments.
%   Orient (double array):      Array of all detected lineament orientations.
%   densityMap_Auto (double):   Final lineament density map.
%--------------------------------------------------------------------------

warning('off','all')

% Grid_Size1 = size(CWT_Input_Features_Matrix)
% Grid_Size2 = size(CWT_Input_Features_Matrix(:))
% Grid_mean = mean(CWT_Input_Features_Matrix(:))


WSFR            = Values(1);       % Wavelet Smoothness Filter Ratio
N_Angles        = Values(2);       % Number of CWT Angles
orderx          = Values(3);       % Derivative Order in X Direction
ordery          = Values(4);       % Derivative Order in Y Direction
Z               = Values(5);       % Derivative Order in Y Direction
w               = Values(6);       % Step Filtering Width
VSFW            = Values(7);       % Variability of Step Filtering Width
GSF_Angles      = Values(8);       % Number of Step Filtering Angles
SLC             = Values(9);       % Strongest Lineament Components (%)
FDissimilarity  = Values(10);       % CWT Feature Dissimilarity
FSaliency       = Values(11);      % CWT Feature Saliency (%)




%% 1. CWT
global XI
global YI
global Y_Pix
global X_Pix
global N_Fs
global in
% global radius2
% global radius1
% global beta
global YI_Real_Ratio

global Shape_Auto
global Shape_Deep_Auto
global Shape_Shallow_Auto

clear Result3D_Auto
clear global Result3D_Auto

clear grm2_vector_Auto
clear global grm2_vector_Auto


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
h = waitbar(0.5,'BHO Optimized Kernel CWT...', 'WindowStyle', 'modal');
frames = java.awt.Frame.getFrames();
frames(end).setAlwaysOnTop(1);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear Feature
clear Fe_All
clear WLFs_allscales
clear WLFs_allangles
clear WL2
clear WL
clear cwtout_abs
clear cwtout
clear cwtmor
clear tX

clear plotH_Auto
clear global plotH_Auto
global plotH_Auto


global pop_choice3

if orderx == ordery
    betad = 90;
else
    betad = 180;
end

Scales = 1:SDF:(N_Scales*SDF);
Angless = betad/(N_Angles) - betad/(N_Angles) : betad/(N_Angles) : betad - betad/(N_Angles);
Angles = Angless*pi/180;

% Determine number of input features
if ndims(CWT_Input_Features_Matrix) == 2
    N_Fs = 1;
else
    szCWT = size(CWT_Input_Features_Matrix);
    N_Fs = szCWT(3);
end

N_CWT = N_Scales * N_Angles * N_Fs;


global pop_choice3

if (strcmp(pop_choice3,'gaus'))
    Fe_All = cwt2D_DerGus_BTO(CWT_Input_Features_Matrix,Scales,Angles,orderx,ordery,WSFR);
elseif (strcmp(pop_choice3,'derpoisson2d'))
    Fe_All = cwt2D_DerPoisson_BTO(CWT_Input_Features_Matrix,Scales,Angles,orderx,ordery,WSFR,Z);
end


% Var_Fe_All = var(Fe_All(:))

close(h);
pause(0.01);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
h = waitbar(0.5,'Save BHO Optimized Kernel CWT Results...', 'WindowStyle', 'modal');
frames = java.awt.Frame.getFrames();
frames(end).setAlwaysOnTop(1);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
global Result3D_Auto
[XI_siz, YI_siz, nn, mm, kk] = size(Fe_All);
% Result3D_Auto = reshape(Fe_All, XI_siz, YI_siz, nn*mm*kk);
Result3D_Auto = reshape(Fe_All, XI_siz, YI_siz, nn*mm, kk);


close(h);
pause(0.01);



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
h = waitbar(0, ' BHO Saliency/Dissimilarity Optimized Feature Selection Calculations...', 'WindowStyle', 'modal');
frames = java.awt.Frame.getFrames();
frames(end).setAlwaysOnTop(1);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Result3D_Size = size(Result3D_Auto, 3);
% DR is passed as a character string from optimizableVariable, convert if not already numeric
if ischar(DR)
    DR_numeric = str2double(DR);
else
    DR_numeric = DR;
end

if Result3D_Size >= DR_numeric
    DR3 = DR_numeric;
else
    DR3 = Result3D_Size;
end

if DR3 <= 0 % Ensure DR2 is at least 1 if there are features
    DR3 = 1;
end


clear Spectral_PCA_Features_Matrix_Auto
clear global Spectral_PCA_Features_Matrix_Auto
global Spectral_PCA_Features_Matrix_Auto 


            % Get the number of principal components to retain
            % D_Reduct0 = app.CWTReductionto.Value;
            % RudimentaryEdgePercentile = app.FeatureSaliencyEditField.Value;
            % MapCorrelationWeight = app.DissimilarityEditField.Value;

            input_ndims = ndims(Result3D_Auto);
            image_count = 1; % Default for a single image or 2D input

            if input_ndims == 2
                 % Handle single 2D input - unlikely for CWT which expects at least 3D (image x scales)
                 % This part might need re-evaluation based on how Result3D is populated for 2D.
                 % Assuming Result3D is at least 3D for meaningful CWT.
                 % SPCA_Features = Result3D_Auto; % This seems incorrect for CWT input
                 Spectral_PCA_Features_Matrix_Auto(:, :, 1) = Result3D_Auto;
                 % warning('Input is 2D. CWT typically operates on 3D data (image x scales). Please check input format.');
                 % Further processing for 2D would be different, skipping for now based on the core request.
                 % close(h); % Close waitbar if we exit early
                 % return; % Exit function
            elseif input_ndims == 3 % Single 3D image (m x n x scales/features)
                image_count = 1;
                % Process the single image
                % SPCA_Features = CWTFeatureSelection(Result3D, D_Reduct0, RudimentaryEdgePercentile, MapCorrelationWeight);
                SPCA_Features = CWTFeatureSelection(Result3D_Auto, DR3, FSaliency, FDissimilarity);

                % Initialize the output matrix
                [rows, cols, ~] = size(SPCA_Features);
                Spectral_PCA_Features_Matrix_Auto = zeros(rows, cols, image_count);

                % Apply masking and combine selected features
                Grid = zeros(rows, cols, size(SPCA_Features, 3)); % Temporary storage for interpolated maps
                SPCA_Features(SPCA_Features == 0) = 1e-12; % Handle zero values

                for k = 1:size(SPCA_Features, 3)
                    SPCA_Featuresk = in .* SPCA_Features(:, :, k);
                    SPCA_Featuresk(SPCA_Featuresk == 0) = NaN; % Set masked values to NaN
                    % Store the interpolated result
                    Grid(:, :, k) = nDstrb2D(SPCA_Featuresk); % Assuming nDstrb2D handles NaN and interpolates
                end

                % Sum the interpolated maps
                multiplied_map = Grid(:,:,1);
                for i = 2:size(Grid, 3)
                    multiplied_map = multiplied_map + Grid(:,:,i);
                end
                % multiplied_map = nDstrb2D(double(multiplied_map)); % This final interpolation might be redundant if nDstrb2D is applied per map

                % Store the combined map for this image
                Spectral_PCA_Features_Matrix_Auto(:, :, 1) = multiplied_map;

            elseif input_ndims == 4 % Multiple 3D images (m x n x scales/features x num_images)
                image_count = size(Result3D_Auto, 4);
                [rows, cols, ~] = size(Result3D_Auto(:,:,:,1)); % Get dimensions of a single image volume

                % Initialize the output matrix to store combined maps for each image
                Spectral_PCA_Features_Matrix_Auto = zeros(rows, cols, image_count);

                for img_idx = 1:image_count
                    waitbar(img_idx / image_count, h, sprintf('Processing Image %d of %d...', img_idx, image_count));

                    % Extract the current image volume
                    current_image_volume = Result3D_Auto(:, :, :, img_idx);

                    % Apply CWT Feature Selection to the current image volume
                    % Assuming CWTFeatureSelection can handle a 3D input (m x n x scales/features)
                    SPCA_Features_current_image = CWTFeatureSelection(current_image_volume, DR3, FSaliency, FDissimilarity);

                    % --- Processing for the current image (similar to the ndims==3 case) ---
                    SPCA_Features_current_image(SPCA_Features_current_image == 0) = 1e-12; % Handle zero values

                    % Initialize temporary storage for interpolated maps for this image
                    Grid_current_image = zeros(rows, cols, size(SPCA_Features_current_image, 3));

                    for k = 1:size(SPCA_Features_current_image, 3)
                        SPCA_Featuresk = in .* SPCA_Features_current_image(:, :, k);
                        SPCA_Featuresk(SPCA_Featuresk == 0) = NaN; % Set masked values to NaN
                        % Store the interpolated result
                        Grid_current_image(:, :, k) = nDstrb2D(SPCA_Featuresk); % Assuming nDstrb2D handles NaN and interpolates
                    end

                    % Sum the interpolated maps for the current image
                    multiplied_map_current_image = Grid_current_image(:,:,1);
                    for i = 2:size(Grid_current_image, 3)
                        multiplied_map_current_image = multiplied_map_current_image + Grid_current_image(:,:,i);
                    end
                    % multiplied_map_current_image = nDstrb2D(double(multiplied_map_current_image)); % Final interpolation?

                    % Store the combined map for the current image in the output matrix
                    Spectral_PCA_Features_Matrix_Auto(:, :, img_idx) = multiplied_map_current_image;
                    % --- End of processing for the current image ---
                end
            end

            % SPCA_Features_Size is now the number of *features* for a single image,
            % not the number of images. You might want a different variable
            % to report the number of images processed.
            % app.CWTReductionto.Value = SPCA_Features_Size; % This line should probably be removed or adjusted

close(h);
pause(0.01);


% 3. Lineaments

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
h = waitbar(0.66, 'BHO Optimized Lineament Extraction with Hysteresis Thresholding...', 'WindowStyle', 'modal');
frames = java.awt.Frame.getFrames();
frames(end).setAlwaysOnTop(1);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grm = w;    % grammes (w)
global X_Pix
global Y_Pix


All_Inputs = Spectral_PCA_Features_Matrix_Auto;

% originalArrayNoNaNPages = All_Inputs;
originalArrayNoNaNPages = cat(3, All_Inputs, All_Data_Matrix);

nanPageIndices = all(all(isnan(originalArrayNoNaNPages), 1), 2);
originalArrayNoNaNPages(:,:,nanPageIndices) = [];

originalArrayNoNaNPages_Size = size(originalArrayNoNaNPages);

if ndims(originalArrayNoNaNPages)==2
    Number_of_Features_used_for_Lineaments_Detection = 1;
elseif ndims(originalArrayNoNaNPages)==3
    Number_of_Features_used_for_Lineaments_Detection = originalArrayNoNaNPages_Size(1,3);
end

grm = w;    % grammes


Grid = (originalArrayNoNaNPages);


numberoffeatures = Number_of_Features_used_for_Lineaments_Detection;

for ttt6 = 1:numberoffeatures
    Grid0_ = (Grid(:,:,ttt6));
    Grid2_ = FilterB(Grid0_,sigma2); Grid2_(isnan(Grid2_)) = 0;
    vari1(ttt6) = 1 / var(double(Grid2_(:)));
end
vari1_std = zscore(vari1);


allOrientations = {}; % Initialize cell array for storing orientations360


for tttt6 = 1:numberoffeatures
    Grid0 = Grid(:,:,tttt6);
    Grid2 = FilterB(Grid0,sigma2); Grid2(isnan(Grid2)) = 0;
    grm2 = round(grm + (VSFW*grm)*vari1_std(tttt6));

    if grm2 <= 1
        grm2 = 1;
    end

    global grm2_vector_Auto
    grm2_vector_Auto(tttt6) = grm2; % Store step filtering width

    clear Griddddd

    Griddddd = imresize(Grid2,Line_Res);
    % data1 = FilterB(Griddddd,sigma2);

    global XI_line_BHO
    global YI_line_BHO
    XI_line_BHO = imresize(XI, Line_Res);
    YI_line_BHO = imresize(YI, Line_Res);


    data1 = im2double(Griddddd);

    I = data1;

    %parameters for step Filtering
    grammes = grm2; % Step Filter Width
    Step_Filter_nAng = GSF_Angles;
    Step_Filter_step = pi/Step_Filter_nAng;  %angle step
    Step_Filter_DTheta = 0:Step_Filter_step:pi-(Step_Filter_step);
    Step_Filter_Dbw = [2 4 6]; %vector of width of main wave

    %step Filtering
    [Y]= step_Filtering(I,grammes, Step_Filter_DTheta,Step_Filter_Dbw, 2);

    %detection of all faults from Y - BW may contains fault faults
    [BW,plotSkel] = getFaultDetection(Y,data1, SLC);

    %detection of strong faults
    % global BWorig
    % BWorig = BW;

    [orientations360] = createRoseDiagrams(BW);
    allOrientations{tttt6} = orientations360; % Collect orientations360


    % --- NEW COMPONENT‐LEVEL FILTER ---
    CC    = bwconncomp(BW);
    stats = regionprops(CC, Y, 'PixelValues');
    strengths = cellfun(@sum, {stats.PixelValues});

    % keep only the top 25% strongest lineament components
    % SLC = 25;
    pct = 100 - SLC;
    th  = prctile(strengths, pct);
    keep = find(strengths >= th);

    BW  = ismember(labelmatrix(CC), keep);




    C = bwconncomp(BW); % Identify connected components
    RS = regionprops(C, 'Area', 'Orientation', 'Centroid'); % Extract region properties
    L = length(RS); % Number of connected components
    % area = [RS(1:L).Area]; % Area of each connected component
    Map = bwlabel(BW, 8); % Label connected components

    % Step 7: Compute feature values for each region
    RS_Y = regionprops(C, Y, 'PixelValues'); % Pixel values for each region
    feat = zeros(L, 2); % Initialize feature matrix

    for i = 1:L
        vec = RS_Y(i).PixelValues; % Pixel values for the region
        feat(i, 1) = sum(vec); % Feature 1: Sum of pixel values
    end
    feat(:, 2) = feat(:, 1); % Feature 2 (same as Feature 1 for simplicity)

    % Step 8: Determine a threshold to classify strong faults
    sv = sort(feat(:, 1), 'descend'); % Sort feature values in descending order
    Number_OF_Faults = round(1.0 * length(sv)); % Select top 100% as strong faults
    Thresh = sv(Number_OF_Faults); % Threshold for strong faults

    % Step 9: Identify labels of regions classified as strong faults
    Labels = find(feat(:, 1) >= Thresh);



    %Plots Detected regions on Depth
    [plotH_] = plotNewColorMap0_(Y,zeros(size(data1)),Map,Labels,'Detected Lineaments',YI_line_BHO(:),XI_line_BHO(:));
    [plotH] = plotNewColorMap0(Y,Y,Map,Labels,'Detected Lineaments',YI_line_BHO(:),XI_line_BHO(:));




    plotH_Auto(:,:,:,tttt6) = plotH;

    plotH00 = (plotH_(:,:,1)+plotH_(:,:,2)+plotH_(:,:,3))/3;
    plotH00 = imbinarize(plotH00);

    CC = bwconncomp(plotH00);
    componentStats = regionprops(CC, 'Area');
    validComponents = find([componentStats.Area] >= 50);
    plotH00 = ismember(labelmatrix(CC), validComponents);

    plotH00 = imcomplement(plotH00);
    plotH0(:,:,tttt6) = plotH00;


end


global Orient
% After the loop, combine all orientations into a single variable
Orient = vertcat(allOrientations{:}); % Combine along the first dimension


plotH1 = zeros(size(plotH_));

for n = 1:numberoffeatures
    plotH1 = imfuse(plotH1,plotH0(:,:,n),'blend');
    plotH1 = imbinarize(plotH1);

end


global YI_Real_Ratio

cropPixels1 = round(0.025 * YI_Real_Ratio * size(plotH1,1), 0);
cropPixels2 = round(0.025 * size(plotH1,2), 0);

% plotH1_Size = size(plotH1)
clear global plotH1_rgb
global plotH1_rgb

plotH1_rgb = im2double(plotH1);

% Define the number of pixels to crop from each side

% Set the border pixels to 0
plotH1_rgb(1:cropPixels1, :, :) = 1;
plotH1_rgb(end-cropPixels1+1:end, :, :) = 1;
plotH1_rgb(:, 1:cropPixels2, :) = 1;
plotH1_rgb(:, end-cropPixels2+1:end, :) = 1;





% Step 7: Stack only Deep lineaments whose grm2_vector exceeds the average
avg_grm2 = mean(grm2_vector_Auto);

% Initialize the fused (stacked) image once
plotH1 = zeros(size(plotH_));  % same 2D size as each plotH0(:,:,n)

for n = 1 : numberoffeatures
    % Only fuse if the step filtering width > average
    if grm2_vector_Auto(n) > avg_grm2
        plotH1 = imfuse(plotH1, plotH0(:,:,n), 'blend');
        plotH1 = imbinarize(plotH1);
    end
end

% Crop edges of the stacked image
clear global plotH1_rgb_Deep
global plotH1_rgb_Deep
plotH1_rgb_Deep = im2double(plotH1);
plotH1_rgb_Deep(1:cropPixels1, :, :) = 1;
plotH1_rgb_Deep(end-cropPixels1+1:end, :, :) = 1;
plotH1_rgb_Deep(:, 1:cropPixels2, :) = 1;
plotH1_rgb_Deep(:, end-cropPixels2+1:end, :) = 1;

% Step 8: Stack only Shallow lineaments whose grm2_vector falls bellow the average
avg_grm2 = mean(grm2_vector_Auto);

% Initialize the fused (stacked) image once
plotH1 = zeros(size(plotH_));  % same 2D size as each plotH0(:,:,n)

for n = 1 : numberoffeatures
    % Only fuse if the step filtering width > average
    if grm2_vector_Auto(n) <= avg_grm2
        plotH1 = imfuse(plotH1, plotH0(:,:,n), 'blend');
        plotH1 = imbinarize(plotH1);
    end
end

% Crop edges of the stacked image
clear global plotH1_rgb_Shallow
global plotH1_rgb_Shallow
plotH1_rgb_Shallow = im2double(plotH1);
cropPixels = 25;
plotH1_rgb_Shallow(1:cropPixels1, :, :) = 1;
plotH1_rgb_Shallow(end-cropPixels1+1:end, :, :) = 1;
plotH1_rgb_Shallow(:, 1:cropPixels2, :) = 1;
plotH1_rgb_Shallow(:, end-cropPixels2+1:end, :) = 1;





pause(0.1);



close(h);
pause(0.01);



% Step 8: Creating Shapefile from lineaments

% Step 8a: For all Lines

Shape_Auto = struct('Geometry', {}, 'X', {}, 'Y', {}, 'Name', {});

for n = 1:numberoffeatures

    % Convert to binary (just in case it's still grayscale)
    clear BW
    BW = plotH0(:,:,n);

    global XI_line_Auto
    global YI_line_Auto


    % Label connected components (lineaments)
    BW = imcomplement(BW);  % if lines are white on black, invert to black lines on white
    BW = bwmorph(BW, 'thin', Inf);  % Optional: Skeletonize the lineaments

    % Extract boundaries or skeleton into pixel coordinates
    [B,L] = bwboundaries(BW, 'noholes');

    % Extract image bounds
    xVec = linspace(min(XI_line_Auto(:)), max(XI_line_Auto(:)), size(BW,2));
    yVec = linspace(min(YI_line_Auto(:)), max(YI_line_Auto(:)), size(BW,1));

    % Preallocate shapefile structure

    currentShape_Auto = struct('Geometry', {}, 'X', {}, 'Y', {}, 'Name', {});

    for k = 1:length(B)
        boundary = B{k};
        rowIdx = boundary(:,1);  % Y
        colIdx = boundary(:,2);  % X

        % Convert pixel indices to real-world coords
        xCoords = xVec(colIdx);
        yCoords = yVec(rowIdx);

        % Store in shapefile format
        currentShape_Auto(k).Geometry = 'Line';
        currentShape_Auto(k).X = xCoords';
        currentShape_Auto(k).Y = yCoords';
        currentShape_Auto(k).Name = ['Fault_', num2str(k)];
    end

    currentShape_Auto = currentShape_Auto(:);  % Ensure it is a column vector
    Shape_Auto = [Shape_Auto; currentShape_Auto];

end




% Step 8b: For Deep Lines

Shape_Deep_Auto = struct('Geometry', {}, 'X', {}, 'Y', {}, 'Name', {});

for n = 1:numberoffeatures

    % Only fuse if the step filtering width > average
    if grm2_vector_Auto(n) > avg_grm2
        % Convert to binary (just in case it's still grayscale)
        clear BW
        BW = plotH0(:,:,n);
    end



    % Label connected components (lineaments)
    BW = imcomplement(BW);  % if lines are white on black, invert to black lines on white
    BW = bwmorph(BW, 'thin', Inf);  % Optional: Skeletonize the lineaments

    % Extract boundaries or skeleton into pixel coordinates
    [B,L] = bwboundaries(BW, 'noholes');

    % Extract image bounds
    xVec = linspace(min(XI_line_Auto(:)), max(XI_line_Auto(:)), size(BW,2));
    yVec = linspace(min(YI_line_Auto(:)), max(YI_line_Auto(:)), size(BW,1));

    % Preallocate shapefile structure

    currentShape_Deep_Auto = struct('Geometry', {}, 'X', {}, 'Y', {}, 'Name', {});

    for k = 1:length(B)
        boundary = B{k};
        rowIdx = boundary(:,1);  % Y
        colIdx = boundary(:,2);  % X

        % Convert pixel indices to real-world coords
        xCoords = xVec(colIdx);
        yCoords = yVec(rowIdx);

        % Store in shapefile format
        currentShape_Deep_Auto(k).Geometry = 'Line';
        currentShape_Deep_Auto(k).X = xCoords';
        currentShape_Deep_Auto(k).Y = yCoords';
        currentShape_Deep_Auto(k).Name = ['Fault_', num2str(k)];
    end

    currentShape_Deep_Auto = currentShape_Deep_Auto(:);  % Ensure it is a column vector
    Shape_Deep_Auto = [Shape_Deep_Auto; currentShape_Deep_Auto];

end


% Step 8c: For Shallow Lines

Shape_Shallow_Auto = struct('Geometry', {}, 'X', {}, 'Y', {}, 'Name', {});

for n = 1:numberoffeatures

    % Only fuse if the step filtering width > average
    if grm2_vector_Auto(n) < avg_grm2
        % Convert to binary (just in case it's still grayscale)
        clear BW
        BW = plotH0(:,:,n);
    end


    % Label connected components (lineaments)
    BW = imcomplement(BW);  % if lines are white on black, invert to black lines on white
    BW = bwmorph(BW, 'thin', Inf);  % Optional: Skeletonize the lineaments

    % Extract boundaries or skeleton into pixel coordinates
    [B,L] = bwboundaries(BW, 'noholes');

    % Extract image bounds
    xVec = linspace(min(XI_line_Auto(:)), max(XI_line_Auto(:)), size(BW,2));
    yVec = linspace(min(YI_line_Auto(:)), max(YI_line_Auto(:)), size(BW,1));

    % Preallocate shapefile structure

    currentShape_Shallow_Auto = struct('Geometry', {}, 'X', {}, 'Y', {}, 'Name', {});

    for k = 1:length(B)
        boundary = B{k};
        rowIdx = boundary(:,1);  % Y
        colIdx = boundary(:,2);  % X

        % Convert pixel indices to real-world coords
        xCoords = xVec(colIdx);
        yCoords = yVec(rowIdx);

        % Store in shapefile format
        currentShape_Shallow_Auto(k).Geometry = 'Line';
        currentShape_Shallow_Auto(k).X = xCoords';
        currentShape_Shallow_Auto(k).Y = yCoords';
        currentShape_Shallow_Auto(k).Name = ['Fault_', num2str(k)];
    end

    currentShape_Shallow_Auto = currentShape_Shallow_Auto(:);  % Ensure it is a column vector
    Shape_Shallow_Auto = [Shape_Shallow_Auto; currentShape_Shallow_Auto];

end



% 4. F-Beta Score Calculation

global X_Pix
global Y_Pix

% data2 = imcomplement(data1);
plotH1_rgb2 = (plotH1_rgb);


% Convert RGB to grayscale
grayImage = rgb2gray(plotH1_rgb2);

% Convert grayscale to binary
binaryImage = imbinarize(grayImage);

% Define the window size
windowSize = 3; % Example: 3x3 window
filterKernel = ones(windowSize, windowSize); % Moving window kernel

% Calculate density map using convolution
global densityMap_Auto
densityMap_Auto = conv2(double(binaryImage), filterKernel, 'same');

% Normalize the density map (optional)
densityMap_Auto = densityMap_Auto / (windowSize^2);

% % Set density map values to 0 where no lineaments are present

densityMap_Auto = (imcomplement(densityMap_Auto));

end
